# Feature Log

This is a quick reference for features that still needed to fully complete the toolchain

- the rest of the instructions
- grouping cog functions to be loaded together
- better testing of the c standard library
- support for large immediates with inline asm (currently need to insert augs/augd explicitly) (done)
- support for getting offsets to labels (for rep and similar instructions) (done? we can use labels for jmps)
- instruction costs for the scheduler
- optimization passes for various things we can do (for example, a for loop of fixed iterations can be implemented using the rep instruction)
- implement cog-based code relocation in a more flexible way. Currently, any functions that should be in a cog for libcalls are expected to start at 0x100.

Libcall rewrite:
1. change lld to look for libcalls starting at pc 0x200 (done)
2. change linker script to load libcalls into a fixed area that the linker can reference (done)
3. look for better ways to mark a symbol as a libcall target

## Merging Upstream To-do List

1. Create CODE_OWNERS.txt
1. Confirm "active community" status
1. Confirm no impacts the IR or how front-end generates IR
1. Implement remainder of instructions
1. Review licensing
1. Format for LLVM's style
1. Split code into patches:
    - Documentation, code owners, new triple, stub classes
    - Tablegen infrastructure
    - MC (to get llvm-mc functioning) and associated tests
    - Remainder of the lowering code and associated tests

# Proposal:

## Introduction

Propeller 2 is a multicore microcontroller that was recently released. I began efforts about a year ago to use the LLVM infrastucture to create a complete C/C++ toolchain, as none otherwise exists. The target backend is now in a complete enough state to upstream the backend into LLVM as an experimental target.

Details about the microcontroller can be found here: https://www.parallax.com/propeller-2/

## Design and Implementation 

The target backend was designed with simplicity in mind. Given the flexibility of the microncontroller, a rather simple ABI was implemented, modeled after a combination of existing targets (namely, AVR, MSP430, and ARM)

Each part of the backend attempts to implemenent the minimal amount of code necessary to ensure functionality, relying on the front end/optimizer/legalizer layers to get the DAG to a state with as close to a 1:1 mapping to Propeller instructions as possible. A small number of custom DAG nodes and pseudo instruction are implemented for DAG nodes that can be created with a small number of real instructions

## Developer Policy Conformance

1. I am the main code owner, with a small number of other community members volunteering some support
1. Propeller 2 has an active community behind it, and ideally the community behind this target backend will grow: https://forums.parallax.com/categories/propeller-2-multicore-microcontroller
1. There are no changes to common/core components of LLVM (other than registering the triple). All changes are isolated to the target backend, a clang toolchain, and creation of a couple custom clang attributes
1. The code conforms to the license and coding standard
1. Documentation: 
    - ISA/Hardware Description/Datasheet/etc: https://www.parallax.com/propeller-2/documentation/
    - ABI: Due to how flexible the hardware is, there's no explicit ABI written, so I wrote my own to describe how binaries generated by this toolchain should behave: https://github.com/ne75/p2llvm/blob/master/docs/Propeller%202%20ABI.md
1. 4 patches will be submitted to cover merging of this target:
    1. Documentation, code owners, new triple, stub classes
    1. Tablegen infrastructure
    1. MC code (to get llvm-mc functioning) and associated tests
    1. Remainder of the lowering code and associated tests
1. Test coverage
    - All instructions encodings are tested. The tests are autogenerated from the instruction set document
    - Basic IR operations that are used in code generation
    - Calling convention for various argument types and organizations
    - All pseudo instructions
